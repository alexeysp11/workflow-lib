# PixelTerminalUI

[English](README.md) | [Русский](README.ru.md)

## Примеры использования

```
------------------------------------
                                    |
                                    |
                                    |
                                    |
             WELCOME TO             |
         PIXEL TERMINAL UI          |
                                    |
                                    |
                                    |
                                    |
                                    |
                                    |
                                    |
                                    |
....................................|
                                    |
                                    |
PRESS ENTER TO CONTINUE             |
------------------------------------
```

Визуализация формы и её элементов производится на стороне сервера. Также возможно определить методы для обработки пользовательского ввода.

Пример формы представлен ниже:

```C#
public class frmStart : BaseForm
{
    private TextControl? lblWelcome;
    private TextControl? lblAppName;

    private TextEditControl? txtUserInput;

    public frmStart() : base()
    {
    }
    
    protected override void InitializeComponent()
    {
        Name = nameof(frmStart);
        
        lblWelcome = new TextControl();
        lblWelcome.Name = nameof(lblWelcome);
        lblWelcome.Top = 4;
        lblWelcome.Left = 0;
        lblWelcome.EntireLine = true;
        lblWelcome.HorizontalAlignment = HorizontalAlignment.Center;
        lblWelcome.Value = "WELCOME TO";
        Controls.Add(lblWelcome);

        lblAppName = new TextControl();
        lblAppName.Name = nameof(lblAppName);
        lblAppName.Top = 5;
        lblAppName.Left = 0;
        lblAppName.EntireLine = true;
        lblAppName.HorizontalAlignment = HorizontalAlignment.Center;
        lblAppName.Value = "PIXEL TERMINAL UI";
        Controls.Add(lblAppName);

        txtUserInput = new TextEditControl();
        txtUserInput.Name = nameof(txtUserInput);
        txtUserInput.Top = 14;
        txtUserInput.Left = 0;
        txtUserInput.EntireLine = true;
        txtUserInput.Hint = "PRESS ENTER TO CONTINUE";
        txtUserInput.EnterValidation = txtUserInput_EnterValidation;
        Controls.Add(txtUserInput);
    }

    private bool txtUserInput_EnterValidation()
    {
        try
        {
            switch (txtUserInput.Value)
            {
                case "":
                case "-n":
                    ShowForm(new frmLogin());
                    break;

                case "-q":
                case "-b":
                    ShowInformation("Are you sure to exit the application?");
                    break;
            }
        }
        finally
        {
            txtUserInput.Value = "";
        }
        return true;
    }
}
```

## Архитектура

Взаимодействие между модулями проекта:

![PixelTerminalUI.architecture](docs/img/PixelTerminalUI.architecture.png)

## Требования

### Движок серверного приложения

Приложение должно обладать следующим фукнционалом:
- [x] С клиента идет TCP-запрос к сервису; сервис обрабатывает запрос и инициирует TCP-соединение.
- [x] Приложение может обрабатывать несколько запросов одновременно.
- [x] Соединение остается постоянным на протяжении всей сессии.
- [ ] Коммуникация в рамках сессии производится в следующем виде:
    - [x] Клиент набирает текст, нажимает Enter, и отправляет новый TCP-запрос на сервис. Сообщение не считается отправленным, пока не был нажат Enter.
    - [ ] Существует набор спецсимволов:
        - `-n`: далее.
        - `-b`: назад.
        - `-q`: выйти.
        - `-h`: помощь.
        - `-i`: информация.
    - [x] В процессе обработки запроса сервис формирует и отправляет некую текстовую информацию в виде двумерного массива символов заданного размера (например, 26 в ширину и 16-18 в высоту).
    - [x] Затем цикл повторяется: клиент набирает сообщение, нажимает Enter, а потом сервис его обрабатывает.
- [ ] Контролы делятся на следующие типы: текстовое поле отображения `TextControl`, текстовое поле ввода `TextEditControl`. Допускается наследоваться от указанных полей и создавать контролы для специализированных нужд (например, ввод пароля, ввод товара с кастомной валидацией). Также допускается определять методы для валидации как делегаты (делегаты будут вызываться в теле метода, выполняющего валидацию; имя метода валидации в контроле начинается с `On`).
    - [x] Текстовое поле отображения `TextControl`:
        - **Наследование**: является базовым.
        - **Поля**: наименование `Name`, координаты `X` и `Y`, ширина `Width`, значение `Value`, видимый `Visible`, выравнивание по горизонтали `HorizontalAlignment`, инвертирование `Inverted`.
        - **Валидация**: валидация перед отображением `ShowValidation` (отображает поле, если оно видимое).
        - Может отображаться на несколько строк.
    - [ ] Текстовое поле ввода `TextEditControl`:
        - **Наследование**: наследуется от `TextControl`.
        - **Поля**: обязательно для заполнения `Required`, `Hint` (подсказка для ввода внизу формы).
        - **Валидация**: валидация перед отображением `ShowValidation` (отображает поле, если оно видимое, также отображает подсказку); валидация перед отображением `RequireValidation` (допускает ввод значений в поле, если оно обязательно для заполнения); валидация ввода `EnterValidation`.
- [x] На форме в методе `InitializeComponent` определяются и регистрируются все контролы, а также свойства этих контролов.
- [x] Есть базовая форма `BaseForm`, которая отображает и обрабатывает контролы: отображение производится сверху вниз и слева направо.
- [ ] Есть класс `MenuFormResolver` для работы с пунктами меню, который выполняет следующие операции:
    - [x] Принимает на вход код операции (например, `0/0/1`, `0/0/2`, `1/0/3`, etc).
    - [x] По коду операции создает экземпляр формы.
    - [ ] Заполняет атрибуты формы.
    - [x] Вызывает методы `Init()` и `Show()` у формы.
    - [ ] Сохраняет данные пользовательской сессии (ИД сессии, пункт меню, отображаемая информация на экране у клиента).

Пример отображения информации представлен ниже:
```
    TCP SERVICE
TEST FORM

REQUEST NUMBER: 1
REQUEST BODY:
..........................
..........................
..........................

RESPONSE BODY:
..........................
..........................
..........................

ENTER REQUEST BODY
```

### Клиентское приложение

- [ ] Клиентское приложение может подключаться к различным протоколам:
    - [x] TCP
    - [x] HTTP
    - [ ] gRPC
- [ ] Для коммуникации с сервисом лучше написать кастомный клиент, запускаемый из командной строки. Таким образом, будут следующие компоненты:
    - [ ] Библиотека сетевого взаимодействия `ClientAdapter`: коммуницирует с сервисом по TCP и возвращает двумерный массив символов.
    - [ ] Консольное приложение: имеет область, в которой отображает информацию; каждый раз после получения ответа от сервиса очищает область отображения.
- [ ] Пункты меню:
    - [ ] `1`: Тестирование.
    - [ ] `2`: Пользователи:
        - [ ] `2/1`: поиск
        - [ ] `2/2`: права доступа пользователей к ресурсам
        - [ ] `2/3`: редактирование пользователя.
    - [ ] `3`: Приложения:
        - [ ] `3/1`: поиск
        - [ ] `3/2`: права доступа приложений/модулей к ресурсам
        - [ ] `3/3`: пункты меню (создание, редактирование, включение/отключение).
        - [ ] `3/4`: развертывание приложений (запустить/настроить сервисы для тестовой среды
        - [ ] `3/5`: локальная копия БД
        - [ ] `3/6`: релиз: выполнить, откатить.
        - [ ] `3/7`: сервисы: связи между сервисами, права доступа сервиса к ресурсам.
    - [ ] `4`: Конфигурационные переменные (найти, просмотреть, редактировать, условия выполнения, указать приложения):
        - [ ] `4/1`: общие переменные
        - [ ] `4/2`: переменные по приложению.
    - [ ] `5`: Задачи:
        - [ ] `5/1`: поиск/редактировать
        - [ ] `5/2`: назначить
        - [ ] `5/3`: отменить.
- [ ] Допускается выбирать пункты меню следюущим образом:
    - [ ] Одиночный пункт меню: например, "1".
    - [ ] Полный путь: например, "/2/3/1".
    - [ ] Относительный путь, когда пользователь уже находится в некотором пункте меню: например, "./3/1" или "./0".

## Способы коммуникации

Для работы данного сервиса можно попробовать различные способы взаимодействия:
1. TCP: проще выполнить коммуникацию, при которой соединение остается постоянным во время всей сессии; однако такой способ взаимодействия менее устойчив к разрыву сети и увеличивает нагрузку на сервер, что особенно плохо при большом количестве клиентов.
2. HTTP/WebAPI: возможно отправлять на клиент некоторую информацию о пользовательской сессии, чтобы не держать соединение постоянно открытым, и можно было восстанавливать сессию даже после разрыва сети; также следует продумать, как сохранять сессию на сервере и отключать неактивные сессии (например, сохранять в БД и отключать с помощью воркера на стороне сервера).
3. gRPC: модель взаимодействия аналогична HTTP/WebAPI.

### HTTP/WebAPI

- Клиент выполняет запрос к сервису, при этом запрос может быть пустым или содержать информацию о сессии.
- Сервис сохраняет информацию о сессиях в памяти:
    - С помощью `appsettings.json` можно настроить следующие параметры: максимальное количество активных сессий, время удержания сессии активной.
    - Для того, чтобы было легче восстановить сессию, можно сохранять её в памяти в словаре, чтобы был доступ по UID сессии (сохранять экземпляр класса `MenuFormResolver` и после нового ввода от пользователя вызывать метод `ProcessUserInput`).
    - Предусмотреть удаление неактивных сессий.
- Сервис выполняет обработку запроса следующим образом:
    - Проверка, что в теле запроса указан параметр `SessionUid`, и этот `SessionUid` находится в списке активных сессий.
        - Если проверка не пройдена, то создать сессию, сохранить её в памяти и отправить ответ клиенту.
        - Если проверка пройдена успешно, то обновить последнее время доступа к сессии и перейти дальше по конвейеру обработки запроса.
    - Проверка данных для авторизации.
    - Обработка пользовательского ввода.
- После обработки запроса, сервис формирует ответ, содержащий данные для отображения, UID сессии, данные пользователя, предыдущий пользовательский ввод.

Пример ответа от сервера:
```JSON
{
    "SessionUid": "fa603a27-e0bc-4580-ac50-dbdd41edd284",
    "FormHeight": 20,
    "FormWidth": 35,
    "MenuCode": "2/3/1",
    "DisplayedInfo": "ERROR:\nTHIS OPERATION IS CANCELLED!",
    "SavedDisplayedInfo": "    TCP SERVICE\nTEST FORM\n\nREQUEST NUMBER: 1\nREQUEST BODY:",
    "UserLogin": "45321",
    "UserInput": "-n"
}
```
